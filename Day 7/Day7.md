# ðŸŽ‰ Day 6: Sorting II ðŸŽ‰

On the 7th day of my #100DaysOfDSA challenge, I covered merge sort and quick sort.
<br>
## Merge Sort:
<b>Time Complexity:</b> O(n log n)<br>
<b>Space Complexity:</b> O(n)<br>

Merge Sort is a popular sorting algorithm that follows the Divide and Conquer approach. It divides the input array into two halves, recursively sorts them, and then merges the sorted halves to produce the final sorted array. Its time complexity is O(n log n), making it efficient for large datasets. However, it requires additional space for the temporary arrays during the merging phase, resulting in a space complexity of O(n).
<br>
## Quick Sort:
<b>Time Complexity:</b> O(n log n)<br>
<b>Space Complexity:</b> O(1) <br>

Quick Sort is another efficient sorting algorithm based on the Divide and Conquer technique. It selects a pivot element, partitions the array around the pivot, and recursively sorts the subarrays on either side of the pivot. The average case time complexity of Quick Sort is O(n log n). Quick Sort generally has lower space complexity than Merge Sort.
<br><br>
Checkout the codes for practice.
